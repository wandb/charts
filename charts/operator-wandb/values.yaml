## NOTICE
#
# Due to the scope and complexity of this chart, all possible values are not
# documented in this file. Extensive documentation is available.
#
# Because properties are regularly added, updated, or relocated, it is _strongly
# suggest_ to not "copy and paste" this YAML. Please provide Helm only those
# properties you need, and allow the defaults to be provided by the version of
# this chart at the time of deployment.

# The global properties are used to configure multiple charts at once.
global:
  # This should be the fqdn of where your users will be accessing the instance.
  host: "http://localhost:8080"
  license: ""

  licenseSecret:
    name: ""
    key: ""

  cloudProvider: ""

  storageClass: ""

  banners:
    {}
    # banner1:
    #   type: warning | error | info
    #   message: "This is a warning message"
    #   heading: "This is a warning"
    #   dismissable: true
    # banner2:
    #   type: warning | error | info
    #   message: "This is a warning message"
    #   heading: "This is a warning"

  common:
    labels: {}
    annotations: {}

  ## Supplemental Pod labels. Will not be used for selectors.
  pod:
    labels: {}
    annotations: {}
  deployment:
    annotations: {}
    labels: {}
  service:
    labels: {}
    annotations: {}

  extraEnvFrom: {}
  extraEnv:
    BUCKET_QUEUE: internal://

  operator:
    namespace: default

  mysql:
    host: ""
    port: 3306
    database: "wandb_local"
    user: "wandb"
    password: ""
    passwordSecret:
      name: ""

  slack:
    secret: ""
    clientId: ""

  clickhouse:
    install: false
    host: ""
    port: 8443
    password: "fake"
    database: "weave_trace_db"
    user: "default"

  email:
    smtp:
      host: ""
      port: 587
      user: ""
      password: ""

  auth:
    sessionLengthHours: 720
    oidc:
      clientId: ""
      secret: ""
      authMethod: ""
      issuer: ""

  # Storage bucket that will be used by the application by default but can be overridden by the user in the wandb-console.
  defaultBucket:
    # az, s3, gcs
    provider: "s3"
    name: ""
    path: ""
    region: ""
    kmsKey: ""
    secretKey: ""
    accessKey: ""
    secretName: ""

  # If specified the application will use this bucket for all storage operations, and will not be overridable by the user.
  bucket:
    secretName: ""

  redis:
    host: ""
    port: 6379
    password: ""
    parameters: {}
    caCert: ""
    # The name of the user supplied secret containing the password for the redis instance.
    secretName: ""

  kafka:
    # The following values are anchored here, and referenced by alias later for
    # the kafka dependency chart.
    user: &kafkaUser "wandb"
    password: &kafkaPassword "wandb"
    brokerHost: ""
    brokerPort: 9092
    runUpdatesShadowTopic: ""
    # This value will only apply upon initial topic creation.
    # If the topic already exists then changing the number of partitions is not possible.
    runUpdatesShadowNumPartitions: 12

  customCACerts: []

  weave-trace:
    enabled: false

ingress:
  install: true
  create: true
  nameOverride: ""
  defaultBackend: "app"
  annotations: {}
  labels: {}
  tls: []
  additionalHosts: []
  class: ""
  issuer:
    create: false
    provider: ""
    server: https://acme-v02.api.letsencrypt.org/directory
    email: support@wandb.com
  secondary:
    create: false
    install: true
    nameOverride: ""
    defaultBackend: "app"
    annotations: {}
    labels: {}
    tls: []
    additionalHosts: []
    class: ""
    issuer:
      create: false
      provider: ""
      server: https://acme-v02.api.letsencrypt.org/directory
      email: support@wandb.com

parquet:
  install: true
  image:
    repository: wandb/local
    tag: latest

app:
  install: true
  env:
    GLUE_ENABLED: "false"
    REDIS:
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_AUDITOR_CACHE
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_SETTINGS_CACHE
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_LOCKER
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_ACTIVITY_STORE_CACHE_ADDRESS
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_CACHE
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_FILE_METADATA_SOURCE
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_GLUE_TASK_STRATEGY_STORE
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_GLUE_TASK_METADATA_STORE
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_USAGE_STORE
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_METADATA_STORE
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_PARQUET_LIVE_HISTORY_STORE
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_ANALYTICS_SINK
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_CASBIN_ADDRESS
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_RUN_STORE
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_FILE_STREAM_STORE_ADDRESS
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_HISTORY_STORE
      value: "http://{{ .Release.Name }}-parquet:8087/_goRPC_,{{ include \"wandb.mysql\" . | trim }}"
    AZURE_STORAGE_KEY:
      valueFrom:
        secretKeyRef:
          name: "{{ include \"wandb.bucket.secret\" . }}"
          key: ACCESS_KEY
          optional: true
    - name: GORILLA_CUSTOMER_SECRET_STORE_K8S_CONFIG_NAMESPACE
      valueFrom:
        fieldRef:
          fieldPath: metadata.namespace
    - name: G_HOST_IP
      valueFrom:
        fieldRef:
          fieldPath: status.hostIP
    - name: GORILLA_RUN_UPDATE_SHADOW_QUEUE
      value: >
        {
          "overflow-bucket": {
            "store": "$(OVERFLOW_BUCKET_ADDR)",
            "name": "wandb",
            "prefix": "wandb-overflow"
          },
          "addr": "kafka://$(KAFKA_CLIENT_USER):$(KAFKA_CLIENT_PASSWORD)@$(KAFKA_BROKER_HOST):$(KAFKA_BROKER_PORT)/$(KAFKA_TOPIC_RUN_UPDATE_SHADOW_QUEUE)?producer_batch_bytes=1048576&num_partitions=$(KAFKA_RUN_UPDATE_SHADOW_QUEUE_NUM_PARTITIONS)&replication_factor=3"
        }
  envFrom:
    - secretRef:
        name: "{{ .Release.Name }}-mysql"
    - secretRef:
        name: "{{ .Release.Name }}-redis"
    - secretRef:
        name: "{{ .Release.Name }}-kafka"
    - secretRef:
        name: "{{ .Release.Name }}-gorilla"
    - configMapRef:
        name: "{{ .Release.Name }}-mysql"
    - configMapRef:
        name: "{{ .Release.Name }}-redis"
    - configMapRef:
        name: "{{ .Release.Name }}-kafka"
    - configMapRef:
        name: "{{ .Release.Name }}-gorilla"
  initContainers:
    - name: init-db
      env: [ ]
      envFrom: [ ]
      command: ['bash', '-c', "until mysql -h$MYSQL_HOST -u$MYSQL_USER -p$MYSQL_PASSWORD -D$MYSQL_DATABASE -P$MYSQL_PORT --execute=\"SELECT 1\"; do echo waiting for db; sleep 2; done"]
  containers:
    - name: app
      env: [ ]
      envFrom: [ ]
      ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        - name: prometheus
          containerPort: 8181
          protocol: TCP
        - name: gorilla-statsd
          containerPort: 8125
          protocol: TCP
      livenessProbe:
        httpGet:
          path: /healthz
          port: http
      readinessProbe:
        httpGet:
          path: /ready
          port: http
        initialDelaySeconds: 20
        periodSeconds: 5
      startupProbe:
        httpGet:
          path: /ready
          port: http
        initialDelaySeconds: 20
        periodSeconds: 5
        failureThreshold: 120
      resources:
        limits:
          cpu: "2"
          memory: 4Gi
        requests:
          cpu: "1"
          memory: 1Gi
      volumeMounts:
        - name: redis-ca
          mountPath: /etc/ssl/certs/redis_ca.pem
          subPath: redis_ca.pem
  volumes:
    - name: redis-ca
      secret:
        secretName: "{{ .Release.Name }}-redis"
        items:
          - key: REDIS_CA_CERT
            path: redis_ca.pem
  service:
    ports:
      - name: http
        port: 8080
        targetPort: http
        protocol: TCP
  image:
    repository: wandb/local
    tag: latest

gorilla:
  traceRatio: 0.0

glue:
  install: true
  service:
    enabled: false
  env:
    - name: REDIS
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_AUDITOR_CACHE
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_SETTINGS_CACHE
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_LOCKER
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_ACTIVITY_STORE_CACHE_ADDRESS
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_CACHE
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_FILE_METADATA_SOURCE
      value: "{{ include \"wandb.redis\" . | trim }}"
    - name: GORILLA_GLUE_TASK_STRATEGY_STORE
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_GLUE_TASK_METADATA_STORE
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_USAGE_STORE
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_METADATA_STORE
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_PARQUET_LIVE_HISTORY_STORE
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_ANALYTICS_SINK
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_CASBIN_ADDRESS
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_RUN_STORE
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_FILE_STREAM_STORE_ADDRESS
      value: "{{ include \"wandb.mysql\" . | trim }}"
    - name: GORILLA_HISTORY_STORE
      value: "http://{{ .Release.Name }}-parquet:8087/_goRPC_,{{ include \"wandb.mysql\" . | trim }}"
  envFrom:
    - secretRef:
        name: "{{ .Release.Name }}-mysql"
    - secretRef:
        name: "{{ .Release.Name }}-redis"
    - secretRef:
        name: "{{ .Release.Name }}-gorilla"
    - configMapRef:
        name: "{{ .Release.Name }}-mysql"
    - configMapRef:
        name: "{{ .Release.Name }}-redis"
    - configMapRef:
        name: "{{ .Release.Name }}-gorilla"
  containers:
    - name: glue
      args: ["glue"]
      env: []
      envFrom: []
      ports:
        - name: http
          containerPort: 8080
          protocol: TCP
      livenessProbe:
        httpGet:
          path: /healthz
          port: 8080
        initialDelaySeconds: 30
        periodSeconds: 1
        timeoutSeconds: 1
        successThreshold: 1
        failureThreshold: 3
      resources:
        limits:
          cpu: "2"
          memory: 4Gi
        requests:
          cpu: "1"
          memory: 1Gi
      volumeMounts:
        - name: redis-ca
          mountPath: /etc/ssl/certs/redis_ca.pem
          subPath: redis_ca.pem
  image:
    repository: wandb/megabinary
    tag: 0.62.0-pre.0
  volumes:
    - name: redis-ca
      secret:
        secretName: "{{ .Release.Name }}-redis"
        items:
          - key: REDIS_CA_CERT
            path: redis_ca.pem

nginx:
  install: false

console:
  install: true
  image:
    repository: wandb/console
    tag: latest

flat-run-fields-updater:
  install: false
  service:
    enabled: false
  envFrom:
    - secretRef:
        name: "{{ .Release.Name }}-mysql"
    - secretRef:
        name: "{{ .Release.Name }}-redis"
    - secretRef:
        name: "{{ .Release.Name }}-kafka"
    - secretRef:
        name: "{{ .Release.Name }}-gorilla"
    - configMapRef:
        name: "{{ .Release.Name }}-mysql"
    - configMapRef:
        name: "{{ .Release.Name }}-redis"
    - configMapRef:
        name: "{{ .Release.Name }}-kafka"
    - configMapRef:
        name: "{{ .Release.Name }}-gorilla"
  containers:
    args: ["flat-run-fields-updater"]
  image:
    repository: wandb/megabinary
    tag: 0.62.0-pre.0

weave:
  install: true
  envFrom:
    - secretRef:
        name: "{{ .Release.Name }}-mysql"
    - secretRef:
        name: "{{ .Release.Name }}-redis"
    - secretRef:
        name: "{{ .Release.Name }}-kafka"
    - secretRef:
        name: "{{ .Release.Name }}-gorilla"
    - configMapRef:
        name: "{{ .Release.Name }}-mysql"
    - configMapRef:
        name: "{{ .Release.Name }}-redis"
    - configMapRef:
        name: "{{ .Release.Name }}-kafka"
    - configMapRef:
        name: "{{ .Release.Name }}-gorilla"
  initContainers:
    - name: init-db
      env: [ ]
      envFrom: [ ]
      command: ['bash', '-c', "until mysql -h$MYSQL_HOST -u$MYSQL_USER -p$MYSQL_PASSWORD -D$MYSQL_DATABASE -P$MYSQL_PORT --execute=\"SELECT 1\"; do echo waiting for db; sleep 2; done"]
  containers:
    - name: weave
      env: [ ]
      envFrom: [ ]
      livenessProbe:
        failureThreshold: 3
        httpGet:
          path: /__weave/hello
          port: http
          scheme: HTTP
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
      ports:
        - containerPort: 9994
          name: http
          protocol: TCP
      readinessProbe:
        failureThreshold: 3
        httpGet:
          path: /__weave/hello
          port: http
          scheme: HTTP
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
      resources:
        limits:
          cpu: "4"
          memory: 16Gi
        requests:
          cpu: 500m
          memory: 1Gi
      startupProbe:
        failureThreshold: 12
        httpGet:
          path: /__weave/hello
          port: http
          scheme: HTTP
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
      volumeMounts:
        - mountPath: /vol/weave/cache
          name: cache
    - name: weave-cache-clear
      command:
        - python
        - -m
        - weave.clear_cache
      env: [ ]
      envFrom: [ ]
      resources:
        requests:
          cpu: 100m
          memory: 128Mi
      volumeMounts:
        - mountPath: /vol/weave/cache
          name: cache
  volumes:
    volumes:
      - emptyDir:
          sizeLimit: 20Gi
        name: cache
  service:
    ports:
      - name: http
        port: 8080
        targetPort: http
        protocol: TCP
  image:
    repository: wandb/local
    tag: latest

weave-trace:
  install: false
  env:
    - name: WEAVE_ENABLED
      value: "true"
    - name: WEAVE_CACHE_DURATION_DAYS
      value: "7"
    - name: PORT
      value: "8080"
    - name: API_PATH_PREFIX
      value: /traces
    - name: WANDB_PUBLIC_BASE_URL
      value: "{{ .Values.global.host }}"
    - name: WANDB_BASE_URL
      value: "http://{{ .Release.Name }}-app:8080/"
    - name: WF_TRACE_SERVER_URL
      value: "{{ .Values.global.host }}/traces"
    - name: WF_CLICKHOUSE_HOST
      valueFrom:
        configMapKeyRef:
          key: CLICKHOUSE_HOST
          name: wandb-clickhouse
    - name: WF_CLICKHOUSE_PORT
      valueFrom:
        configMapKeyRef:
          key: CLICKHOUSE_PORT
          name: wandb-clickhouse
    - name: WF_CLICKHOUSE_DATABASE
      valueFrom:
        configMapKeyRef:
          key: CLICKHOUSE_DATABASE
          name: wandb-clickhouse
    - name: WF_CLICKHOUSE_HOST
      valueFrom:
        configMapKeyRef:
          key: CLICKHOUSE_HOST
          name: wandb-clickhouse
    - name: WF_CLICKHOUSE_PASS
      valueFrom:
        secretKeyRef:
          key: CLICKHOUSE_PASSWORD
          name: wandb-clickhouse
    - name: GORILLA_WEAVE_CLICKHOUSE_ADDRESS
      value: "clickhouse://gorilla_usage_stats@$(WF_CLICKHOUSE_HOST):$(WF_CLICKHOUSE_PORT)/$(WF_CLICKHOUSE_DATABASE)"
  containers:
    - name: weave-trace
      env: [ ]
      envFrom: [ ]
      livenessProbe:
        failureThreshold: 5
        httpGet:
          path: /traces/health
          port: http
          scheme: HTTP
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 2
      ports:
        - containerPort: 8080
          name: http
          protocol: TCP
      readinessProbe:
        failureThreshold: 5
        httpGet:
          path: /traces/health
          port: http
          scheme: HTTP
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 2
      resources:
        limits:
          cpu: "1"
          memory: 6Gi
        requests:
          cpu: 500m
          memory: 1Gi
      startupProbe:
        failureThreshold: 12
        httpGet:
          path: /traces/health
          port: http
          scheme: HTTP
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1
  initContainers:
    - name: weave-trace-migrate
      command:
          - python
          - migrator.py
      env: [ ]
      envFrom: [ ]
      resources:
          requests:
          cpu: 100m
          memory: 128Mi
  image:
    repository: wandb/weave-trace-dev
    tag: 0.62.0-pre-test-release.0
  datadog:
    enabled: false

mysql:
  install: false
  persistence:
    size: 20Gi
    storageClass: ""

yace:
  install: false
  regions: ["ap-south-1"]
  pod:
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "5000"
      prometheus.io/path: "/metrics"
      prometheus.io/scheme: http

redis:
  install: true
  nameOverride: "redis"
  architecture: standalone
  auth:
    enabled: false
  metrics:
    enabled: false
    service:
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9121"
        prometheus.io/path: "/metrics"

prometheus:
  install: true

  instance:
    install: true

  redis-exporter:
    install: true

  mysql-exporter:
    install: true

stackdriver:
  install: false
  pod:
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9255"
      prometheus.io/path: "/metrics"
      prometheus.io/scheme: http

otel:
  install: true

  # Consider deploying with a deployment rather than a daemonset to avoid
  # redundant metrics. In setups where both are scraping the same endpoints,
  # this redundancy occurs as both scrape the same points.
  daemonset:
    install: true

  # By default, we use only the daemonset which, along with the Prometheus
  # receiver, gathers most necessary metrics.
  # - To forward Kafka metrics to an external system, you will need to scrape a
  #   promethus endpoint which causes duplicated metrics that get repoted.
  deployment:
    install: false

#   # cannot use install because schema validation will fail.
#   enabled: true

#   resources:
#     limits:
#       cpu: 100m
#       memory: 200M
#   configMap:
#     create: false

#   command:
#     name: otelcol-contrib
#     extraArgs: ["--config=/conf/config.yaml"]
#   extraVolumes:
#     - name: "otel-config"
#       configMap:
#         name: "otel-config"
#         items:
#           - key: config
#             path: config.yaml
#         defaultMode: 420
#   extraVolumeMounts:
#     - name: "otel-config"
#       mountPath: /conf/config.yaml

nameOverride: ""
fullnameOverride: ""

# It is *strongly* recommended to supply passwords yourself for production installs.
kafka:
  install: false
  controller:
    persistence:
      size: 30Gi
  sasl:
    interbroker:
      password: "inter-broker"
    controller:
      password: "controller-pw"
    # The client usernames and passwords are alias references from the global values section at the beginning of this file.
    # Please update the values there to ensure proper propagation to the application
    client:
      users:
        - *kafkaUser
      passwords: *kafkaPassword
  kraft:
    # This field is a UUID. It is *strongly* recommended to supply a new UUID yourself for production installs.
    clusterId: "ffFF1H3AQKGdBnsqAbJKew"
  metrics:
    jmx:
      enabled: true
